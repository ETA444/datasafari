<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <link rel="shortcut icon" href="../../../_static/favicon.ico"/><!-- Generated with Sphinx 7.3.7 and Furo 2024.05.06 -->
        <title>datasafari.transformer.transform_num - DataSafari 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=387cc868" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" /
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">DataSafari 1.0.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logos/ds-branding-logo-big-lightmode.png" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logos/ds-branding-logo-big-darkmode.png" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">DataSafari 1.0.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glance.html">Subpackages Overview</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Explorers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../datasafari.explorer.explore_df.html">explore_df()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../datasafari.explorer.explore_num.html">explore_num()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../datasafari.explorer.explore_cat.html">explore_cat()</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Transformers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../datasafari.transformer.transform_num.html">transform_num()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../datasafari.transformer.transform_cat.html">transform_cat()</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Evaluators</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../datasafari.evaluator.evaluate_normality.html">evaluate_normality()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../datasafari.evaluator.evaluate_variance.html">evaluate_variance()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../datasafari.evaluator.evaluate_dtype.html">evaluate_dtype()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../datasafari.evaluator.evaluate_contingency_table.html">evaluate_contingency_table()</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Predictors</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../datasafari.predictor.predict_hypothesis.html">predict_hypothesis()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../datasafari.predictor.predict_ml.html">predict_ml()</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">General Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lic-gpl3.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contact.html">Contact</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for datasafari.transformer.transform_num</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span><span class="p">,</span> <span class="n">MinMaxScaler</span><span class="p">,</span> <span class="n">QuantileTransformer</span><span class="p">,</span> <span class="n">RobustScaler</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">boxcox</span><span class="p">,</span> <span class="n">yeojohnson</span>
<span class="kn">from</span> <span class="nn">scipy.stats.mstats</span> <span class="kn">import</span> <span class="n">winsorize</span>
<span class="kn">from</span> <span class="nn">datasafari.evaluator.evaluate_dtype</span> <span class="kn">import</span> <span class="n">evaluate_dtype</span>


<div class="viewcode-block" id="transform_num">
<a class="viewcode-back" href="../../../datasafari.transformer.transform_num.html#datasafari.transformer.transform_num">[docs]</a>
<span class="k">def</span> <span class="nf">transform_num</span><span class="p">(</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">numerical_variables</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">output_distribution</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;normal&#39;</span><span class="p">,</span>
        <span class="n">n_quantiles</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">444</span><span class="p">,</span>
        <span class="n">with_centering</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">quantile_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">25.0</span><span class="p">,</span> <span class="mf">75.0</span><span class="p">),</span>
        <span class="n">power</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">power_map</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lower_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">upper_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.99</span><span class="p">,</span>
        <span class="n">winsorization_map</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">interaction_pairs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">degree</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">degree_map</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bins</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bin_map</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    **Transform numerical variables in a DataFrame through operations like standardization, log-transformation, various scalings, winsorization, interaction term creation and more.**</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    df : pd.DataFrame</span>
<span class="sd">        The DataFrame containing the numerical data to transform.</span>

<span class="sd">    numerical_variables : list</span>
<span class="sd">        A list of column names in `df` that are numerical and will be transformed.</span>

<span class="sd">    method : str</span>
<span class="sd">        The transformation method to apply.</span>
<span class="sd">            - ``&#39;standardize&#39;`` Mean=0, SD=1. Suitable for algorithms sensitive to variable scales.</span>
<span class="sd">            - ``&#39;log&#39;`` Natural logarithm transformation for positively skewed data.</span>
<span class="sd">            - ``&#39;normalize&#39;`` Scales data to a [0, 1] range. Useful for models sensitive to variable scales.</span>
<span class="sd">            - ``&#39;quantile&#39;`` Transforms data to follow a specified distribution, improving statistical analysis.</span>
<span class="sd">            - ``&#39;robust&#39;`` Scales data using the median and quantile range, reducing the influence of outliers.</span>
<span class="sd">            - ``&#39;boxcox&#39;`` Normalizes skewed data, requires positive values.</span>
<span class="sd">            - ``&#39;yeojohnson&#39;`` Similar to Box-Cox but suitable for both positive and negative values.</span>
<span class="sd">            - ``&#39;power&#39;`` Raises numerical variables to specified powers for distribution adjustment.</span>
<span class="sd">            - ``&#39;winsorization&#39;`` Caps extreme values to reduce impact of outliers.</span>
<span class="sd">            - ``&#39;interaction&#39;`` Creates new features by multiplying pairs of numerical variables.</span>
<span class="sd">            - ``&#39;polynomial&#39;`` Generates polynomial features up to a specified degree.</span>
<span class="sd">            - ``&#39;bin&#39;`` Groups numerical data into bins or intervals.</span>

<span class="sd">    output_distribution : str, optional, default: &#39;normal&#39;</span>
<span class="sd">        Specifies the output distribution for &#39;quantile&#39; method (&#39;normal&#39; or &#39;uniform&#39;).</span>

<span class="sd">    n_quantiles : int, optional, default: 1000</span>
<span class="sd">        Number of quantiles to use for &#39;quantile&#39; method.</span>

<span class="sd">    random_state : int, optional, default: 444</span>
<span class="sd">        Random state for &#39;quantile&#39; method.</span>

<span class="sd">    with_centering : bool, optional, default: True</span>
<span class="sd">        Whether to center data before scaling for &#39;robust&#39; method.</span>

<span class="sd">    quantile_range : tuple, optional, default: (25.0, 75.0)</span>
<span class="sd">        Quantile range used for &#39;robust&#39; method.</span>

<span class="sd">    power : float, optional, default: None</span>
<span class="sd">        The power to raise each numerical variable for &#39;power&#39; method.</span>

<span class="sd">    power_map : dict, optional, default: None</span>
<span class="sd">        A dictionary mapping variables to their respective powers for &#39;power&#39; method.</span>

<span class="sd">    lower_percentile : float, optional, default: 0.01</span>
<span class="sd">        Lower percentile for &#39;winsorization&#39;.</span>

<span class="sd">    upper_percentile : float, optional, default: 0.99</span>
<span class="sd">        Upper percentile for &#39;winsorization&#39;.</span>

<span class="sd">    winsorization_map : dict, optional, default: None</span>
<span class="sd">        A dictionary specifying winsorization bounds per variable.</span>

<span class="sd">    interaction_pairs : list, optional, default: None</span>
<span class="sd">        List of tuples specifying pairs of variables for creating interaction terms.</span>

<span class="sd">    degree : int, optional, default: None</span>
<span class="sd">        The degree for polynomial features in &#39;polynomial&#39; method. Default is None.</span>

<span class="sd">    degree_map : dict, optional, default: None</span>
<span class="sd">        A dictionary mapping variables to their respective degrees for &#39;polynomial&#39; method.</span>

<span class="sd">    bins : int, optional, default: None</span>
<span class="sd">        The number of equal-width bins to use for &#39;bin&#39; method.</span>

<span class="sd">    bin_map : dict, optional, default: None</span>
<span class="sd">        A dictionary specifying custom binning criteria per variable for &#39;bin&#39; method.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    Tuple[pd.DataFrame, pd.DataFrame]</span>
<span class="sd">        - Original DataFrame with transformed numerical variables.</span>
<span class="sd">        - A DataFrame containing only the transformed columns.</span>

<span class="sd">    Raises:</span>
<span class="sd">    -------</span>
<span class="sd">    TypeErrors:</span>
<span class="sd">        - If `df` is not a pandas DataFrame.</span>
<span class="sd">        - If `numerical_variables` is not a list.</span>
<span class="sd">        - If `method` is not a string.</span>
<span class="sd">        - If `output_distribution` is provided but not a string.</span>
<span class="sd">        - If `n_quantiles` is not an integer.</span>
<span class="sd">        - If `random_state` is not an integer.</span>
<span class="sd">        - If `with_centering` is not a boolean.</span>
<span class="sd">        - If `quantile_range` is not a tuple of two floats.</span>
<span class="sd">        - If `power` is provided but not a float.</span>
<span class="sd">        - If `power_map`, `winsorization_map`, `degree_map`, or `bin_map` is provided but not a dictionary.</span>
<span class="sd">        - If `lower_percentile` or `upper_percentile` is not a float.</span>
<span class="sd">        - If `interaction_pairs` is not a list of tuples, or tuples are not of length 2.</span>
<span class="sd">        - If `degree` is provided but not an integer.</span>
<span class="sd">        - If `bins` is provided but not an integer.</span>

<span class="sd">    ValueErrors:</span>
<span class="sd">        - If the input DataFrame is empty.</span>
<span class="sd">        - If &#39;numerical_variables&#39; list is empty.</span>
<span class="sd">        - If variables provided through &#39;numerical_variables&#39; are not numerical variables.</span>
<span class="sd">        - If any of the specified `numerical_variables` are not found in the DataFrame&#39;s columns.</span>
<span class="sd">        - If the `method` specified is not one of the valid methods.</span>
<span class="sd">        - If `output_distribution` is not &#39;normal&#39; or &#39;uniform&#39; for the &#39;quantile&#39; method.</span>
<span class="sd">        - If `n_quantiles` is not a positive integer for the &#39;quantile&#39; method.</span>
<span class="sd">        - If `quantile_range` does not consist of two float values in the range 0 to 1 for the &#39;robust&#39; method.</span>
<span class="sd">        - If `power` is not provided for the &#39;power&#39; method when required.</span>
<span class="sd">        - If `lower_percentile` or `upper_percentile` is not between 0 and 1, or if `lower_percentile` is greater than or equal to `upper_percentile` for the &#39;winsorization&#39; method.</span>
<span class="sd">        - If `degree` is not provided or is not a positive integer for the &#39;polynomial&#39; method when required.</span>
<span class="sd">        - If `bins` is not a positive integer for the &#39;bin&#39; method when required.</span>
<span class="sd">        - If method is &#39;log&#39;, &#39;boxcox&#39; or &#39;yeojohnson&#39; and the provided columns have NAs or Infs raise as these statistical methods are not compatible with NAs or Infs.</span>
<span class="sd">        - If specified keys in `power_map`, `winsorization_map`, `degree_map`, or `bin_map` do not match any column in the DataFrame.</span>
<span class="sd">        - If the `interaction_pairs` specified do not consist of columns that exist in the DataFrame.</span>

<span class="sd">    Examples:</span>
<span class="sd">    ---------</span>
<span class="sd">    Import necessary libraries and generate a DataFrame for examples:</span>

<span class="sd">    &gt;&gt;&gt; import datasafari</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">    ...     &#39;Feature1&#39;: np.random.normal(0, 1, 100),</span>
<span class="sd">    ...     &#39;Feature2&#39;: np.random.exponential(1, 100),</span>
<span class="sd">    ...     &#39;Feature3&#39;: np.random.randint(1, 100, 100)</span>
<span class="sd">    ... })</span>
<span class="sd">    &gt;&gt;&gt; num_cols = [&#39;Feature1&#39;, &#39;Feature2&#39;, &#39;Feature3&#39;]</span>

<span class="sd">    Standardize:</span>

<span class="sd">    &gt;&gt;&gt; standardized_data, standardized_cols = transform_num(df, num_cols, method=&#39;standardize&#39;)</span>

<span class="sd">    Log transformation:</span>

<span class="sd">    &gt;&gt;&gt; log_data, log_cols = transform_num(df, num_cols, method=&#39;log&#39;)</span>

<span class="sd">    Normalize:</span>

<span class="sd">    &gt;&gt;&gt; normalized_data, normalized_cols = transform_num(df, num_cols, method=&#39;normalize&#39;)</span>

<span class="sd">    Quantile transformation:</span>

<span class="sd">    &gt;&gt;&gt; quant_transformed_data, quant_transformed_cols = transform_num(df, num_cols, method=&#39;quantile&#39;, output_distribution=&#39;normal&#39;, n_quantiles=1000, random_state=444)</span>

<span class="sd">    Robust scaling:</span>

<span class="sd">    &gt;&gt;&gt; robust_transformed_df, robust_transformed_columns = transform_num(df, num_cols, method=&#39;robust&#39;, with_centering=True, quantile_range=(25.0, 75.0))</span>

<span class="sd">    Box-Cox transformation:</span>

<span class="sd">    &gt;&gt;&gt; boxcox_transformed_df, boxcox_transformed_columns = transform_num(df, num_cols, method=&#39;boxcox&#39;)</span>

<span class="sd">    Yeo-Johnson transformation:</span>

<span class="sd">    &gt;&gt;&gt; yeojohnson_transformed_df, yeojohnson_transformed_columns = transform_num(df, num_cols, method=&#39;yeojohnson&#39;)</span>

<span class="sd">    Power transformation using a uniform power:</span>

<span class="sd">    &gt;&gt;&gt; power_transformed_df1, power_transformed_columns1 = transform_num(df, num_cols, method=&#39;power&#39;, power=2)</span>

<span class="sd">    Power transformation using a power map:</span>

<span class="sd">    &gt;&gt;&gt; power_map = {&#39;Feature1&#39;: 2, &#39;Feature2&#39;: 3, &#39;Feature3&#39;: 4}</span>
<span class="sd">    &gt;&gt;&gt; power_transformed_df2, power_transformed_columns2 = transform_num(df, num_cols, method=&#39;power&#39;, power_map=power_map)</span>

<span class="sd">    Winsorization with global thresholds:</span>

<span class="sd">    &gt;&gt;&gt; wins_transformed_df1, wins_transformed_columns1 = transform_num(df, num_cols, method=&#39;winsorization&#39;, lower_percentile=0.01, upper_percentile=0.99)</span>

<span class="sd">    Winsorization using a winsorization map:</span>

<span class="sd">    &gt;&gt;&gt; win_map = {&#39;Feature1&#39;: (0.01, 0.99), &#39;Feature2&#39;: (0.05, 0.95), &#39;Feature3&#39;: [0.10, 0.90]}</span>
<span class="sd">    &gt;&gt;&gt; wins_transformed_df2, wins_transformed_columns2 = transform_num(df, num_cols, method=&#39;winsorization&#39;, winsorization_map=win_map)</span>

<span class="sd">    Interaction terms:</span>

<span class="sd">    &gt;&gt;&gt; interactions = [(&#39;Feature1&#39;, &#39;Feature2&#39;), (&#39;Feature2&#39;, &#39;Feature3&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; inter_transformed_df, inter_columns = transform_num(df, num_cols, method=&#39;interaction&#39;, interaction_pairs=interactions)</span>

<span class="sd">    Polynomial features with a degree map:</span>

<span class="sd">    &gt;&gt;&gt; degree_map = {&#39;Feature1&#39;: 2, &#39;Feature2&#39;: 3}</span>
<span class="sd">    &gt;&gt;&gt; poly_transformed_df, poly_features = transform_num(df, [&#39;Feature1&#39;, &#39;Feature2&#39;], method=&#39;polynomial&#39;, degree_map=degree_map)</span>

<span class="sd">    Binning with a bin map:</span>

<span class="sd">    &gt;&gt;&gt; bin_map = {&#39;Feature2&#39;: {&#39;bins&#39;: 5}, &#39;Feature3&#39;: {&#39;edges&#39;: [1, 20, 40, 60, 80, 100]}}</span>
<span class="sd">    &gt;&gt;&gt; bin_transformed_df, binned_columns = transform_num(df, [&#39;Feature2&#39;, &#39;Feature3&#39;], method=&#39;bin&#39;, bin_map=bin_map)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Error-handling #</span>

    <span class="c1"># TypeErrors</span>
    <span class="c1"># Check if &#39;df&#39; is a pandas DataFrame</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;df&#39; parameter must be a pandas DataFrame.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;numerical_variables&#39; is a list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">numerical_variables</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;numerical_variables&#39; parameter must be a list of column names.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">numerical_variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): All elements in the &#39;numerical_variables&#39; list must be strings representing column names.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;method&#39; is a string</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;method&#39; parameter must be a string.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;output_distribution&#39; is a string</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_distribution</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;output_distribution&#39; parameter must be a string.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;n_quantiles&#39; is an integer</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_quantiles</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;n_quantiles&#39; parameter must be an integer.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;random_state&#39; is an integer</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;random_state&#39; parameter must be an integer.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;with_centering&#39; is a boolean</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">with_centering</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;with_centering&#39; parameter must be a boolean.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;quantile_range&#39; is a tuple and contains two floats</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">quantile_range</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">quantile_range</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">quantile_range</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;quantile_range&#39; parameter must be a tuple containing two float values.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;power&#39; is None, int, or float</span>
    <span class="k">if</span> <span class="n">power</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;power&#39; parameter must be a float, integer, or None.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;power_map&#39; is None or a dictionary</span>
    <span class="k">if</span> <span class="n">power_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">power_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;power_map&#39; parameter must be a dictionary or None.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;lower_percentile&#39; and &#39;upper_percentile&#39; are floats</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lower_percentile</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">upper_percentile</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;lower_percentile&#39; and &#39;upper_percentile&#39; parameters must be floats.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;winsorization_map&#39; is None or a dictionary</span>
    <span class="k">if</span> <span class="n">winsorization_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">winsorization_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;winsorization_map&#39; parameter must be a dictionary or None.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;interaction_pairs&#39; is None or a list of tuples</span>
    <span class="k">if</span> <span class="n">interaction_pairs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">interaction_pairs</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">interaction_pairs</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;interaction_pairs&#39; parameter must be a list of tuples or None.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;degree&#39; is None or an integer</span>
    <span class="k">if</span> <span class="n">degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;degree&#39; parameter must be an integer or None.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;degree_map&#39; is None or a dictionary</span>
    <span class="k">if</span> <span class="n">degree_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">degree_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;degree_map&#39; parameter must be a dictionary or None.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;bins&#39; is None or an integer</span>
    <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;bins&#39; parameter must be an integer or None.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;bin_map&#39; is None or a dictionary</span>
    <span class="k">if</span> <span class="n">bin_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bin_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;bin_map&#39; parameter must be a dictionary or None.&quot;</span><span class="p">)</span>

    <span class="c1"># ValueErrors</span>
    <span class="c1"># Check if df is empty</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;explore_num(): The input DataFrame is empty.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if list has any members</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numerical_variables</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;numerical_variables&#39; list must contain at least one column name.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if variables are numerical</span>
    <span class="n">numerical_types</span> <span class="o">=</span> <span class="n">evaluate_dtype</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">numerical_variables</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;list_n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">numerical_types</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;numerical_variables&#39; list must contain only names of numerical variables.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if specified variables exist in the DataFrame</span>
    <span class="n">missing_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">numerical_variables</span> <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">missing_vars</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;transform_num(): The following numerical variables were not found in the DataFrame: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing_vars</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Check if method is valid</span>
    <span class="n">valid_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;standardize&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;normalize&#39;</span><span class="p">,</span> <span class="s1">&#39;quantile&#39;</span><span class="p">,</span> <span class="s1">&#39;robust&#39;</span><span class="p">,</span> <span class="s1">&#39;boxcox&#39;</span><span class="p">,</span> <span class="s1">&#39;yeojohnson&#39;</span><span class="p">,</span> <span class="s1">&#39;power&#39;</span><span class="p">,</span> <span class="s1">&#39;winsorization&#39;</span><span class="p">,</span> <span class="s1">&#39;interaction&#39;</span><span class="p">,</span> <span class="s1">&#39;polynomial&#39;</span><span class="p">,</span> <span class="s1">&#39;bin&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_methods</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;transform_num(): Invalid method &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39;. Valid options are: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">valid_methods</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># For &#39;quantile&#39; method specific checks</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;quantile&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">output_distribution</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="s1">&#39;uniform&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): Invalid &#39;output_distribution&#39; for &#39;quantile&#39; method. Choose &#39;normal&#39; or &#39;uniform&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_quantiles</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n_quantiles</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;n_quantiles&#39; must be a positive integer.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;random_state&#39; must be an integer.&quot;</span><span class="p">)</span>

    <span class="c1"># For &#39;robust&#39; method specific checks</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;robust&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">with_centering</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;with_centering&#39; parameter must be a boolean (True or False).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">quantile_range</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">quantile_range</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">quantile_range</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;quantile_range&#39; must be a tuple of two float values.&quot;</span><span class="p">)</span>

    <span class="c1"># For &#39;power&#39; method specific checks</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;power&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">power</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;power&#39; parameter must be a float, integer, or None.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">power_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">power_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;power_map&#39; must be a dictionary mapping variables to powers or None.&quot;</span><span class="p">)</span>

    <span class="c1"># For &#39;winsorization&#39; method specific checks</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;winsorization&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">lower_percentile</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">lower_percentile</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;lower_percentile&#39; must be a float between 0 and 1.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">upper_percentile</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">upper_percentile</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;upper_percentile&#39; must be a float between 0 and 1.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lower_percentile</span> <span class="o">&gt;=</span> <span class="n">upper_percentile</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;lower_percentile&#39; must be less than &#39;upper_percentile&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># For &#39;polynomial&#39; method specific checks</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;polynomial&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">degree</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;degree&#39; must be a positive integer or None.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">degree_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">degree_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;degree_map&#39; must be a dictionary mapping variables to degrees or None.&quot;</span><span class="p">)</span>

    <span class="c1"># For &#39;bin&#39; method specific checks</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;bin&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">bins</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;bins&#39; must be a positive integer or None.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bin_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bin_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;bin_map&#39; must be a dictionary specifying binning criteria or None.&quot;</span><span class="p">)</span>

    <span class="c1"># For &#39;interaction&#39; method specific checks</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">interaction_pairs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">interaction_pairs</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">interaction_pairs</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_num(): The &#39;interaction_pairs&#39; must be a list of tuples specifying pairs of variables or None.&quot;</span><span class="p">)</span>
            <span class="n">missing_pairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">interaction_pairs</span> <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">missing_pairs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;transform_num(): The following variable pairs in &#39;interaction_pairs&#39; were not found in the DataFrame: </span><span class="si">{</span><span class="n">missing_pairs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Check for NaN or infinite values in the DataFrame for methods that cannot handle them</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;boxcox&#39;</span><span class="p">,</span> <span class="s1">&#39;yeojohnson&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">df</span><span class="p">[</span><span class="n">numerical_variables</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">numerical_variables</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;transform_num(): The &#39;numerical_variables&#39; contain NaN or infinite values, which are not compatible with the &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; method.&quot;</span><span class="p">)</span>

    <span class="c1"># Additional checks for mapping dictionaries to ensure keys exist in the DataFrame</span>
    <span class="k">if</span> <span class="n">power_map</span> <span class="ow">or</span> <span class="n">winsorization_map</span> <span class="ow">or</span> <span class="n">degree_map</span> <span class="ow">or</span> <span class="n">bin_map</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">map_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">power_map</span><span class="p">,</span> <span class="n">winsorization_map</span><span class="p">,</span> <span class="n">degree_map</span><span class="p">,</span> <span class="n">bin_map</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;power_map&#39;</span><span class="p">,</span> <span class="s1">&#39;winsorization_map&#39;</span><span class="p">,</span> <span class="s1">&#39;degree_map&#39;</span><span class="p">,</span> <span class="s1">&#39;bin_map&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">mapping</span><span class="p">:</span>
                <span class="n">invalid_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">invalid_keys</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;transform_num(): The following keys in &#39;</span><span class="si">{</span><span class="n">map_name</span><span class="si">}</span><span class="s2">&#39; were not found in the DataFrame columns: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invalid_keys</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Main Function #</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;standardize&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; STANDARDIZING DATA &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method centers the data around mean 0 with a standard deviation of 1, enhancing model performance and stability.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Standardizes each numerical variable to have mean=0 and variance=1.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Essential preprocessing step for many machine learning algorithms.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✎ Note: Standardization is applied only to the specified numerical variables.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize essential objects</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>

        <span class="c1"># scale the data</span>
        <span class="n">transformed_df</span><span class="p">[</span><span class="n">numerical_variables</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">numerical_variables</span><span class="p">])</span>

        <span class="c1"># isolate transformed columns to give as part of output</span>
        <span class="n">standardized_columns</span> <span class="o">=</span> <span class="n">transformed_df</span><span class="p">[</span><span class="n">numerical_variables</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only the transformed columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">standardized_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO - Apply this transformation using `transformed_df, standardized_columns = transform_num(your_df, your_numerical_variables, method=&#39;standardize&#39;)`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of original dataframe: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of transformed dataframe: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">standardized_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; LOG TRANSFORMATION &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method applies a natural logarithm transformation to positively skewed data.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Helps to stabilize variance and make the data more normally distributed.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Particularly useful for data with a heavy right tail (positively skewed).</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✎ Note: Log transformation is applied only to specified numerical variables. Zero or negative values in the data can cause issues and will skip those columns.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize essential objects</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">log_transformed_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">skipped_columns</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># do the operation only after checking provided column for zero or negative values</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">numerical_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;⚠️ Warning: &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; contains zero or negative values and was skipped to avoid log(0) and negative log issues.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ Note: The log transformation requires strictly positive values. For data with zero or negative values, consider using the &#39;yeojohnson&#39; method as an alternative.&quot;</span><span class="p">)</span>
                <span class="n">skipped_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">transformed_column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">])</span>
                <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_column</span>
                <span class="n">log_transformed_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">log_transformed_columns</span><span class="p">,</span> <span class="n">transformed_column</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; has been log-transformed.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># inform user if a column was skipped</span>
        <span class="k">if</span> <span class="n">skipped_columns</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✘ Skipped columns due to non-positive values: </span><span class="si">{</span><span class="n">skipped_columns</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only the transformed columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">log_transformed_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO: Apply this transformation using `transformed_df, log_transformed_columns = transform_num(your_df, your_numerical_variables, method=&#39;log&#39;)`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of original dataframe: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of transformed dataframe: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Consider examining the distribution of your data post-transformation.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">log_transformed_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;normalize&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; NORMALIZATION TRANSFORMATION &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method scales numerical variables to a [0, 1] range, making them suitable for models sensitive to variable scales.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Adjusts each feature to a [0, 1] scale based on its minimum and maximum values.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Enhances model performance by ensuring numerical variables are on a similar scale.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✎ Note: Ensure data is clean and outliers are handled for optimal results.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ Tip: Use `explore_num()` for data inspection and outlier detection before applying normalization.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize essentials</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">min_max_scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>

        <span class="c1"># apply minmax scaling</span>
        <span class="n">transformed_df</span><span class="p">[</span><span class="n">numerical_variables</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_max_scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">numerical_variables</span><span class="p">])</span>

        <span class="c1"># isolate transformed columns to provide as part of output</span>
        <span class="n">normalized_columns</span> <span class="o">=</span> <span class="n">transformed_df</span><span class="p">[</span><span class="n">numerical_variables</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only the transformed columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">normalized_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO: Apply this transformation using `transformed_df, normalized_columns = transform_num(your_df, your_numerical_variables, method=&#39;normalize&#39;)`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of original dataframe: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of transformed dataframe: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">normalized_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;quantile&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; QUANTILE TRANSFORMATION &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; This method maps the data to a &#39;</span><span class="si">{</span><span class="n">output_distribution</span><span class="si">}</span><span class="s2">&#39; distribution and n_quantiles = </span><span class="si">{</span><span class="n">n_quantiles</span><span class="si">}</span><span class="s2">. Random state set to </span><span class="si">{</span><span class="n">random_state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ✔ Transforms skewed or outlier-affected data to follow a standard </span><span class="si">{</span><span class="s1">&#39;normal&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">output_distribution</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">&#39;normal&#39;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;uniform&#39;</span><span class="si">}</span><span class="s2"> distribution, improving statistical analysis and ML model accuracy.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ✔ Utilizes </span><span class="si">{</span><span class="n">n_quantiles</span><span class="si">}</span><span class="s2"> quantiles to finely approximate the empirical distribution, capturing the detailed data structure while balancing computational efficiency.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ Tip: The choice of 1000 quantiles as a default provides a good compromise between detailed distribution mapping and practical computational demands. Adjust as needed based on dataset size and specificity.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize the DataFrame to work with</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># define and apply Quantile Transformer</span>
        <span class="n">quantile_transformer</span> <span class="o">=</span> <span class="n">QuantileTransformer</span><span class="p">(</span><span class="n">output_distribution</span><span class="o">=</span><span class="n">output_distribution</span><span class="p">,</span> <span class="n">n_quantiles</span><span class="o">=</span><span class="n">n_quantiles</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">transformed_df</span><span class="p">[</span><span class="n">numerical_variables</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantile_transformer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">numerical_variables</span><span class="p">])</span>

        <span class="c1"># isolate transformed columns to give as part of output</span>
        <span class="n">quantile_transformed_columns</span> <span class="o">=</span> <span class="n">transformed_df</span><span class="p">[</span><span class="n">numerical_variables</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only the transformed columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">quantile_transformed_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO: Apply this transformation using `transformed_df, quantile_transformed_columns = transform_num(your_df, your_numerical_variables, method=&#39;quantile&#39;, output_distribution=&#39;normal&#39;, n_quantiles=1000, random_state=444)`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of original dataframe: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of transformed dataframe: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* After transformation, evaluate your data&#39;s distribution and consider its impact on your analysis or modeling approach.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">quantile_transformed_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;robust&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; ROBUST SCALING TRANSFORMATION &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method scales your data by removing the median and scaling according to the quantile range.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Targets data with outliers by using median and quantiles, reducing the influence of extreme values.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Centers and scales data to be robust against outliers, improving model performance on skewed data.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✎ Note: With centering is </span><span class="si">{</span><span class="s1">&#39;enabled&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">with_centering</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;disabled&#39;</span><span class="si">}</span><span class="s2">. Adjust `with_centering` as needed (provide bool).</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;☻ Tip: The quantile range is set to </span><span class="si">{</span><span class="n">quantile_range</span><span class="si">}</span><span class="s2">. You can adjust it based on your data&#39;s distribution.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize essentials</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">RobustScaler</span><span class="p">(</span><span class="n">with_centering</span><span class="o">=</span><span class="n">with_centering</span><span class="p">,</span> <span class="n">quantile_range</span><span class="o">=</span><span class="n">quantile_range</span><span class="p">)</span>

        <span class="c1"># apply the defined robust scaler</span>
        <span class="n">transformed_df</span><span class="p">[</span><span class="n">numerical_variables</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">numerical_variables</span><span class="p">])</span>

        <span class="c1"># Isolate transformed columns to give as part of output</span>
        <span class="n">robust_scaled_columns</span> <span class="o">=</span> <span class="n">transformed_df</span><span class="p">[</span><span class="n">numerical_variables</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only the transformed columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">robust_scaled_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO: Apply this transformation using `transformed_df, robust_scaled_columns = transform_num(your_df, your_numerical_variables, method=&#39;robust&#39;, with_centering=True, quantile_range=(25.0, 75.0))`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of original dataframe: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of transformed dataframe: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* After transformation, evaluate the robustness of your data against outliers and consider the effect on your analysis or modeling.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">robust_scaled_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;boxcox&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; BOX-COX TRANSFORMATION &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method applies the Box-Cox transformation to numerical variables to normalize their distribution.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Transforms skewed data to closely approximate a normal distribution.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Automatically finds and applies the optimal transformation parameter (lambda) for each variable.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✎ Note: Box-Cox transformation requires all data to be positive. Columns with zero or negative values will be skipped.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize essential objects</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">boxcox_transformed_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">skipped_columns</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># check column values and apply boxcox only on appropriate data</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">numerical_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;⚠️ Warning: &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; contains zero or negative values and was skipped to avoid issues with Box-Cox transformation.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ Tip: The Box-Cox transformation requires strictly positive values. For data including zero or negative values, the &#39;yeojohnson&#39; method provides a flexible alternative.&quot;</span><span class="p">)</span>
                <span class="n">skipped_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">transformed_column</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">boxcox</span><span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">])</span>
                <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_column</span>
                <span class="n">boxcox_transformed_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">boxcox_transformed_columns</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">transformed_column</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">variable</span><span class="p">])],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; has been Box-Cox transformed.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># inform user of any columns that were skipped</span>
        <span class="k">if</span> <span class="n">skipped_columns</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✘ Skipped columns due to non-positive values: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">skipped_columns</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only the Box-Cox transformed columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">boxcox_transformed_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO: Apply this transformation using `transformed_df, boxcox_transformed_columns = transform_num(your_df, your_numerical_variables, method=&#39;boxcox&#39;)`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of original dataframe: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of transformed dataframe: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* After transformation, evaluate your data&#39;s distribution and consider its impact on your analysis or modeling approach.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">boxcox_transformed_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;yeojohnson&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; YEO-JOHNSON TRANSFORMATION &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method transforms data to closely approximate a normal distribution, applicable to both positive and negative values.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Stabilizes variance and normalizes distribution.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Suitable for a wide range of data, including zero and negative values.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize the DataFrame to work with</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">yeojohnson_transformed_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># Apply Yeo-Johnson transformation</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">numerical_variables</span><span class="p">:</span>
            <span class="n">transformed_column</span><span class="p">,</span> <span class="n">lambda_value</span> <span class="o">=</span> <span class="n">yeojohnson</span><span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">])</span>
            <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_column</span>
            <span class="n">yeojohnson_transformed_columns</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_column</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; has been transformed using Yeo-Johnson. Lambda value: </span><span class="si">{</span><span class="n">lambda_value</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only the Yeo-Johnson transformed columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">yeojohnson_transformed_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO: Apply this transformation using `transformed_df, yeojohnson_transformed_columns = transform_num(your_df, your_numerical_variables, method=&#39;yeojohnson&#39;)`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of original dataframe: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of transformed dataframe: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Review the transformed data and consider its implications for your analysis or modeling strategy.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">yeojohnson_transformed_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;power&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">power</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">power_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; POWER TRANSFORMATION &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method raises numerical variables to specified powers, allowing for precise data distribution adjustments.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Individual powers can be set per variable using a &#39;power_map&#39; for targeted transformations.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Alternatively, a single &#39;power&#39; value applies uniformly to all specified numerical variables.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Facilitates skewness correction and distribution normalization to improve statistical analysis and ML model performance.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ Tip: A power of 0.5 (square root) often works well for right-skewed data, while a square (power of 2) can help with left-skewed data. Choose the power that best fits your data characteristics.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize essential objects</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">power_transformed_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># determine transformation approach</span>
        <span class="k">if</span> <span class="n">power_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">pwr</span> <span class="ow">in</span> <span class="n">power_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">numerical_variables</span><span class="p">:</span>
                    <span class="n">transformed_column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span> <span class="n">pwr</span><span class="p">)</span>
                    <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_column</span>
                    <span class="n">power_transformed_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">power_transformed_columns</span><span class="p">,</span> <span class="n">transformed_column</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; has been transformed with a power of </span><span class="si">{</span><span class="n">pwr</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">numerical_variables</span><span class="p">:</span>
                <span class="n">transformed_column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span> <span class="n">power</span><span class="p">)</span>
                <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_column</span>
                <span class="n">power_transformed_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">power_transformed_columns</span><span class="p">,</span> <span class="n">transformed_column</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; uniformly transformed with a power of </span><span class="si">{</span><span class="n">power</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only the power transformed columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">power_transformed_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO: Apply this transformation using `transformed_df, power_transformed_columns = transform_num(your_df, your_numerical_variables, method=&#39;power&#39;, power_map=your_power_map)`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of original dataframe: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of transformed dataframe: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Evaluate the distribution post-transformation to ensure it aligns with your analytical or modeling goals.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">power_transformed_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;winsorization&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">lower_percentile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">upper_percentile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">winsorization_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; WINSORIZATION TRANSFORMATION &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method caps extreme values in the data to reduce the impact of outliers.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✎ Note: Specify `lower_percentile` and `upper_percentile` for all variables, or use `winsorization_map` for variable-specific thresholds.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize objects</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">winsorized_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># determine transformation approach</span>
        <span class="k">if</span> <span class="n">winsorization_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">bounds</span> <span class="ow">in</span> <span class="n">winsorization_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">numerical_variables</span><span class="p">:</span>
                    <span class="n">transformed_column</span> <span class="o">=</span> <span class="n">winsorize</span><span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span> <span class="n">limits</span><span class="o">=</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_column</span>
                    <span class="n">winsorized_columns</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_column</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; has been winsorized with bounds </span><span class="si">{</span><span class="n">bounds</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;⚠️ Warning: &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; specified in `winsorization_map` was not found in `numerical_variables` and has been skipped.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">numerical_variables</span><span class="p">:</span>
                <span class="n">transformed_column</span> <span class="o">=</span> <span class="n">winsorize</span><span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span> <span class="n">limits</span><span class="o">=</span><span class="p">(</span><span class="n">lower_percentile</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">upper_percentile</span><span class="p">))</span>
                <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_column</span>
                <span class="n">winsorized_columns</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_column</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; has been winsorized with lower percentile = </span><span class="si">{</span><span class="n">lower_percentile</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s2">% and upper percentile = </span><span class="si">{</span><span class="n">upper_percentile</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s2">%.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only the power transformed columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">winsorized_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO: Apply this transformation using `transformed_df, winsorized_columns = transform_num(your_df, your_numerical_variables, method=&#39;winsorization&#39;, lower_percentile=0.01, upper_percentile=0.99)` for global thresholds, or provide `winsorization_map` for variable-specific thresholds.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of original dataframe: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of transformed dataframe: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* After transformation, review the distribution of your numerical variables to ensure outliers have been appropriately capped.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">winsorized_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; INTERACTION TERMS TRANSFORMATION &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method creates new features by multiplying together pairs of numerical variables.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Captures the synergistic effects between variables that may impact the target variable.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Can unveil complex relationships not observable through individual variables alone.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✎ Note: Specify pairs of variables using &#39;interaction_pairs&#39;, which is a list of tuples, where tuples are variable pairs.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize essential objects</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">interaction_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># check if interaction_pairs is provided</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">interaction_pairs</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;⚠️ No &#39;interaction_pairs&#39; provided. Please specify pairs of variables for interaction terms. Where the object is a list of tuples, and each tuple is a pair of variables.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># create interaction terms</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">interaction_pairs</span><span class="p">:</span>
            <span class="n">new_column_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;interaction_</span><span class="si">{</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">_x_</span><span class="si">{</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">interaction_columns</span><span class="p">[</span><span class="n">new_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_df</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">transformed_df</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Created interaction term &#39;</span><span class="si">{</span><span class="n">new_column_name</span><span class="si">}</span><span class="s2">&#39; based on variables &#39;</span><span class="si">{</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Add interaction columns to the transformed DataFrame</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">transformed_df</span><span class="p">,</span> <span class="n">interaction_columns</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only the interaction columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">interaction_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO: Apply this transformation using `transformed_df, interaction_columns = transform_num(your_df, your_numerical_variables, method=&#39;interaction&#39;, interaction_pairs=[(&#39;var1&#39;, &#39;var2&#39;), (&#39;var3&#39;, &#39;var4&#39;)])`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Original dataframe shape: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Transformed dataframe shape: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">interaction_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;polynomial&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">degree_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; POLYNOMIAL FEATURES TRANSFORMATION &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method generates polynomial features up to a specified degree for numerical variables.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Captures non-linear relationships between variables and the target.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Enhances model performance by adding complexity through feature engineering.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✎ Note: Specify the &#39;degree&#39; for a global application or &#39;degree_map&#39; for variable-specific degrees.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize essential objects</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">poly_features</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># function to apply either global degree or degree from degree_map</span>
        <span class="k">def</span> <span class="nf">apply_degree</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">power</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Start from 2 as degree 1 is the original variable</span>
                <span class="n">new_column_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">_degree_</span><span class="si">{</span><span class="n">power</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">poly_features</span><span class="p">[</span><span class="n">new_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">**</span> <span class="n">power</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Created polynomial feature &#39;</span><span class="si">{</span><span class="n">new_column_name</span><span class="si">}</span><span class="s2">&#39; from variable &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; to the power of </span><span class="si">{</span><span class="n">power</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># check if degree_map is provided and apply</span>
        <span class="k">if</span> <span class="n">degree_map</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">var_degree</span> <span class="ow">in</span> <span class="n">degree_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">numerical_variables</span><span class="p">:</span>
                    <span class="n">apply_degree</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">var_degree</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;⚠️ Variable &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; specified in `degree_map` was not found in `numerical_variables` and has been skipped.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># if degree_map is not provided, use global degree for all variables</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">numerical_variables</span><span class="p">:</span>
                <span class="n">apply_degree</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

        <span class="c1"># Add polynomial features to the transformed DataFrame</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">transformed_df</span><span class="p">,</span> <span class="n">poly_features</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe with polynomial features:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only the polynomial features:</span><span class="se">\n</span><span class="si">{</span><span class="n">poly_features</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO: Apply this transformation using `transformed_df, poly_features = transform_num(your_df, your_numerical_variables, method=&#39;polynomial&#39;, degree=3)` or by specifying a `degree_map`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Original dataframe shape: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Transformed dataframe shape: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* After applying polynomial features, evaluate the model&#39;s performance and watch out for overfitting, especially when using high degrees.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">poly_features</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;bin&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">bin_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; BINNING TRANSFORMATION &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method groups numerical data into bins or intervals, simplifying relationships and reducing noise.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Users can specify a uniform number of bins for all variables or define custom binning criteria per variable.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✎ Note: Binning can be specified globally with &#39;bins&#39; or individually with &#39;bin_map&#39;.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">binned_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">bins</span><span class="p">:</span>
            <span class="c1"># Apply a uniform number of bins across all variables</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">numerical_variables</span><span class="p">:</span>
                <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span> <span class="n">bins</span><span class="p">,</span> <span class="n">retbins</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">bins</span><span class="p">))</span>
                <span class="n">binned_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">binned_columns</span><span class="p">,</span> <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; has been binned into </span><span class="si">{</span><span class="n">bins</span><span class="si">}</span><span class="s2"> intervals.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">bin_map</span><span class="p">:</span>
            <span class="c1"># Apply custom binning based on the provided map</span>
            <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">specs</span> <span class="ow">in</span> <span class="n">bin_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">numerical_variables</span><span class="p">:</span>
                    <span class="n">n_bins</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bins&#39;</span><span class="p">)</span>
                    <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;edges&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">bin_edges</span><span class="p">:</span>
                        <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">retbins</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">retbins</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">n_bins</span><span class="p">))</span>
                    <span class="n">binned_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">binned_columns</span><span class="p">,</span> <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; has been custom binned based on provided specifications.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe with binned variables:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only the binned columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">binned_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO: Apply this transformation using `transformed_df, binned_columns = transform_num(your_df, your_numerical_variables, method=&#39;bin&#39;, bins=3)` or use bin_map.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of original dataframe: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of transformed dataframe: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Review the binned data to ensure it aligns with your analysis or modeling strategy.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">binned_columns</span></div>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, George Dreemer
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=8d563738"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=4e2eecee"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    </body>
</html>