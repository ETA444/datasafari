<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <link rel="shortcut icon" href="../../../_static/favicon.ico"/><!-- Generated with Sphinx 7.3.7 and Furo 2024.05.06 -->
        <title>datasafari.transformer.transform_cat - DataSafari Documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=387cc868" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" /
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">DataSafari Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logos/ds-branding-logo-big-lightmode.png" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logos/ds-branding-logo-big-darkmode.png" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">DataSafari Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glance.html">Subpackages Overview</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Explorers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../explorers/explore_df.html">explore_df()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../explorers/explore_num.html">explore_num()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../explorers/explore_cat.html">explore_cat()</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Transformers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../transformers/transform_num.html">transform_num()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../transformers/transform_cat.html">transform_cat()</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Evaluators</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../evaluators/evaluate_normality.html">evaluate_normality()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../evaluators/evaluate_variance.html">evaluate_variance()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../evaluators/evaluate_dtype.html">evaluate_dtype()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../evaluators/evaluate_contingency_table.html">evaluate_contingency_table()</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Predictors</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../predictors/predict_hypothesis.html">predict_hypothesis()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../predictors/predict_ml.html">predict_ml()</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../other/installation.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">General Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../other/lic-gpl3.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../other/contact.html">Contact</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for datasafari.transformer.transform_cat</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">OneHotEncoder</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="kn">import</span> <span class="n">linkage</span><span class="p">,</span> <span class="n">fcluster</span>
<span class="kn">import</span> <span class="nn">Levenshtein</span> <span class="k">as</span> <span class="nn">lev</span>
<span class="kn">from</span> <span class="nn">category_encoders</span> <span class="kn">import</span> <span class="n">BinaryEncoder</span>
<span class="kn">from</span> <span class="nn">datasafari.evaluator.evaluate_dtype</span> <span class="kn">import</span> <span class="n">evaluate_dtype</span>


<div class="viewcode-block" id="transform_cat">
<a class="viewcode-back" href="../../../transformers/transform_cat.html#datasafari.transformer.transform_cat">[docs]</a>
<span class="k">def</span> <span class="nf">transform_cat</span><span class="p">(</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">categorical_variables</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">na_placeholder</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;Unknown&#39;</span><span class="p">,</span>
        <span class="n">abbreviation_map</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ordinal_map</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target_variable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    **Transform categorical variables in a DataFrame through a range of encoding options and basic to advanced machine learning-based methods for uniform data cleaning.**</span>

<span class="sd">    This is a versatile tool designed for comprehensive transformation and encoding of categorical data in a DataFrame. It accommodates everything from simple text standardization to sophisticated category consolidation using ML and various encoding schemes, catering to both nominal and ordinal data.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    df : pd.DataFrame</span>
<span class="sd">        The DataFrame containing the categorical data to transform.</span>

<span class="sd">    categorical_variables : list</span>
<span class="sd">        A list of strings representing the names of the categorical columns to be transformed.</span>

<span class="sd">    method : str</span>
<span class="sd">        The method to use for transforming the categorical variables.</span>
<span class="sd">            - ``&#39;uniform_simple&#39;`` Basic cleaning transformations to standardize text, such as lowercase conversion, whitespace trimming, and special character removal. Also fills missing values with a specified placeholder.</span>
<span class="sd">            - ``&#39;uniform_smart&#39;`` Advanced cleaning that leverages Levenshtein distance for textual similarity and hierarchical clustering to group and normalize similar categories. Builds on &#39;uniform_simple&#39; preprocessing steps.</span>
<span class="sd">            - ``&#39;uniform_mapping&#39;`` Allows for manual mapping of categories based on user-defined rules to handle specific cases that automated methods might not cover.</span>
<span class="sd">            - ``&#39;encode_onehot&#39;`` Converts categories into binary columns for each category. Suitable for nominal data where no ordinal relationship exists.</span>
<span class="sd">            - ``&#39;encode_ordinal&#39;`` Maps categories to an integer array based on the order defined in `ordinal_map`. Suitable for ordinal data where the order of categories is important.</span>
<span class="sd">            - ``&#39;encode_freq&#39;`` Transforms categories based on the frequency of each category, replacing the category name with its frequency count.</span>
<span class="sd">            - ``&#39;encode_target&#39;`` Encodes categories based on the mean of the target variable for each category. This method should be used cautiously to avoid data leakage and is recommended to be applied within a cross-validation loop.</span>
<span class="sd">            - ``&#39;encode_binary&#39;`` Utilizes binary encoding to transform categories into binary columns, reducing dimensionality and dataset size compared to one-hot encoding. Ideal for high cardinality features.</span>

<span class="sd">    na_placeholder : str, optional, default: &#39;Unknown&#39;</span>
<span class="sd">        The placeholder value to use for missing values during transformations.</span>

<span class="sd">    abbreviation_map : dict, optional, default: None</span>
<span class="sd">        A dictionary specifying manual mappings for categories, used with the &#39;uniform_mapping&#39; method.</span>
<span class="sd">            - Each key should be the name of a categorical variable, and its value should be another dictionary mapping original category values to their new values.</span>

<span class="sd">    ordinal_map : dict, optional, default: None</span>
<span class="sd">        A dictionary specifying the order of categories for ordinal encoding, used with the &#39;encode_ordinal&#39; method.</span>
<span class="sd">            - Each key should be the name of a categorical variable, and its value should be a list of categories in the desired order. This method treats the order of categories as meaningful and encodes them as integers based on the provided order.</span>

<span class="sd">    target_variable : str, optional, default: None</span>
<span class="sd">        The name of the target variable for target encoding. Used with the &#39;encode_target&#39; method.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    Tuple[pd.DataFrame, pd.DataFrame]</span>
<span class="sd">        - Original DataFrame with transformed categorical variables.</span>
<span class="sd">        - A DataFrame containing only the transformed columns.</span>

<span class="sd">    Raises:</span>
<span class="sd">    -------</span>
<span class="sd">    TypeErrors:</span>
<span class="sd">        - If `df` is not a pandas DataFrame.</span>
<span class="sd">        - If `categorical_variables` is not a list or contains elements that are not strings.</span>
<span class="sd">        - If `method`, `na_placeholder`, or `target_variable` is not a strings.</span>
<span class="sd">        - If `abbreviation_map` or `ordinal_map`  is not a dictionary.</span>

<span class="sd">    ValueErrors:</span>
<span class="sd">        - If the input DataFrame is empty.</span>
<span class="sd">        - If &#39;categorical_variables&#39; list is empty.</span>
<span class="sd">        - If variables provided through &#39;categorical_variables&#39; are not categorical variables.</span>
<span class="sd">        - If any variable specified in `categorical_variables` is not found in the DataFrame&#39;s columns.</span>
<span class="sd">        - If `method` is not one of the valid options.</span>
<span class="sd">        - If `method` is &#39;encode_ordinal&#39; and `ordinal_map` is not provided.</span>
<span class="sd">        - If `method` is &#39;encode_target&#39; and `target_variable` is not provided.</span>
<span class="sd">        - If `method` is &#39;uniform_mapping&#39; and `abbreviation_map` is not provided.</span>
<span class="sd">        - If `target_variable` is specified but not found in the DataFrame&#39;s columns.</span>
<span class="sd">        - If keys specified in `abbreviation_map` or `ordinal_map` are not found in the DataFrame&#39;s columns.</span>

<span class="sd">    Examples:</span>
<span class="sd">    ---------</span>
<span class="sd">    Import necessary libraries and generate a DataFrame for examples:</span>

<span class="sd">    &gt;&gt;&gt; import datasafari</span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">        ...     &#39;Category&#39;: [&#39;Student&#39;, &#39;student&#39;, &#39;STUDENT&#39;, &#39;StUdEnT&#39;, &#39;high school&#39;, &#39;High School&#39;, &#39;high   school&#39;, &#39;hgh schl&#39;],</span>
<span class="sd">        ...     &#39;Target&#39;: np.random.randint(0, 2, 8)</span>
<span class="sd">        ... })</span>

<span class="sd">    Apply ``&#39;uniform_simple&#39;`` method to clean up ```Category`` column:</span>

<span class="sd">    &gt;&gt;&gt; transformed_df, uniform_simple_cols = transform_cat(df, [&#39;Category&#39;], method=&#39;uniform_simple&#39;)</span>

<span class="sd">    Apply ``&#39;uniform_smart&#39;`` method to clean up more complex issues in the column using ML techniques:</span>

<span class="sd">    &gt;&gt;&gt; transformed_df, uniform_smart_cols = transform_cat(transformed_df, [&#39;Category&#39;], method=&#39;uniform_smart&#39;)</span>
<span class="sd">    &gt;&gt;&gt; # Note: &#39;uniform_smart&#39; already has &#39;uniform_simple&#39; built-in, however to save resources you can run smart only if needed.</span>

<span class="sd">    Apply ``&#39;uniform_mapping&#39;`` method with a custom abbreviation map to clean up the more stubborn issues that ``uniform_smart`` did not catch:</span>

<span class="sd">    &gt;&gt;&gt; abbreviation_map = {&#39;Category&#39;: {&#39;hgh schl&#39;: &#39;high school&#39;}}</span>
<span class="sd">    &gt;&gt;&gt; transformed_df, uniform_mapped_cols = transform_cat(transformed_df, [&#39;Category&#39;], method=&#39;uniform_mapping&#39;, abbreviation_map=abbreviation_map)</span>

<span class="sd">    Using the various encoding methods now that the data is clean:</span>

<span class="sd">    &gt;&gt;&gt; # Apply &#39;encode_onehot&#39; method:</span>
<span class="sd">    &gt;&gt;&gt; transformed_onehot_df, onehot_cols = transform_cat(transformed_df, [&#39;Category&#39;], method=&#39;encode_onehot&#39;)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; # Apply &#39;encode_ordinal&#39; method with a custom ordinal map:</span>
<span class="sd">    &gt;&gt;&gt; ordinal_map = {&#39;Category&#39;: [&#39;student&#39;, &#39;high school&#39;]}</span>
<span class="sd">    &gt;&gt;&gt; transformed_ordinal_df, ordinal_cols = transform_cat(transformed_df, [&#39;Category&#39;], method=&#39;encode_ordinal&#39;, ordinal_map=ordinal_map)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; # Apply &#39;encode_freq&#39; method:</span>
<span class="sd">    &gt;&gt;&gt; transformed_freq_df, freq_cols = transform_cat(transformed_df, [&#39;Category&#39;], method=&#39;encode_freq&#39;)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; # Apply &#39;encode_target&#39; method with a specified target variable:</span>
<span class="sd">    &gt;&gt;&gt; transformed_target_df, target_cols = transform_cat(transformed_df, [&#39;Category&#39;], method=&#39;encode_target&#39;, target_variable=&#39;Target&#39;)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; # Apply &#39;encode_binary&#39; method:</span>
<span class="sd">    &gt;&gt;&gt; transformed_binary_df, binary_cols = transform_cat(transformed_df, [&#39;Category&#39;], method=&#39;encode_binary&#39;)</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    **`uniform_simple` Method:**</span>
<span class="sd">    This method provides a foundational approach to cleaning categorical data by implementing several straightforward transformations to standardize and simplify the text data. Here’s a breakdown of the steps involved:</span>

<span class="sd">        1. **Lowercase Conversion**: All characters in the text are converted to lowercase to eliminate inconsistencies caused by varied capitalizations.</span>

<span class="sd">        2. **Whitespace Trimming**: Leading and trailing spaces are removed from each string to ensure cleanliness and uniformity in the text data.</span>

<span class="sd">        3. **Special Characters Removal**: Non-alphanumeric characters are removed to standardize the text and reduce noise in the data. This step is crucial for preparing data for machine learning models, which may be sensitive to such variations.</span>

<span class="sd">        4. **Missing Values Handling**: Missing values are replaced with a specified placeholder, defaulting to &#39;Unknown&#39;. This ensures that no data point is lost due to absence of information, and helps maintain the integrity of the dataset during further transformations.</span>

<span class="sd">    **`uniform_smart` Method:**</span>
<span class="sd">    Building on the principles of `uniform_simple`, the `uniform_smart` method incorporates advanced techniques to address more complex variations in text data that simple transformations might miss:</span>

<span class="sd">        1. **Initial Preprocessing**: Executes all steps of `uniform_simple` to prepare the data, setting a standardized baseline for further processing.</span>

<span class="sd">        2. **Textual Similarity Evaluation**: Utilizes the Levenshtein distance, a measure of the difference between two strings, to quantify the similarity between categories. This metric helps identify and group textually similar categories, even if they are not exactly the same.</span>

<span class="sd">        3. **Hierarchical Clustering**: Applies hierarchical clustering to the similarity matrix generated from the Levenshtein distances. This statistical method groups categories based on their textual closeness, which allows for the aggregation of variations of the same category.</span>

<span class="sd">        4. **Cluster Representative Selection**: Within each identified cluster, a representative category is chosen to stand for all the categories within that cluster. Typically, the most frequent category within the cluster is selected as the representative, ensuring that the most common terminology is used in the dataset.</span>

<span class="sd">        5. **Category Normalization**: Each original category is mapped to its cluster representative, normalizing the dataset by reducing the variation due to synonyms, misspellings, and other irregularities.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Error-Handling #</span>

    <span class="c1"># TypeErrors</span>
    <span class="c1"># Check if &#39;df&#39; is a pandas DataFrame</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_cat(): The &#39;df&#39; parameter must be a pandas DataFrame.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;categorical_variables&#39; is a list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">categorical_variables</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_cat(): The &#39;categorical_variables&#39; parameter must be a list of column names.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">categorical_variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_cat(): All elements in the &#39;categorical_variables&#39; list must be strings representing column names.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;method&#39; is a string</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_cat(): The &#39;method&#39; parameter must be a string.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;na_placeholder&#39; is a string</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">na_placeholder</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_cat(): The &#39;na_placeholder&#39; parameter must be a string.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;abbreviation_map&#39;, if provided, is a dictionary</span>
    <span class="k">if</span> <span class="n">abbreviation_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">abbreviation_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_cat(): The &#39;abbreviation_map&#39; parameter must be a dictionary if provided.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;ordinal_map&#39;, if provided, is a dictionary</span>
    <span class="k">if</span> <span class="n">ordinal_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ordinal_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_cat(): The &#39;ordinal_map&#39; parameter must be a dictionary if provided.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if &#39;target_variable&#39;, if provided, is a string</span>
    <span class="k">if</span> <span class="n">target_variable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_variable</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transform_cat(): The &#39;target_variable&#39; parameter must be a string if provided.&quot;</span><span class="p">)</span>

    <span class="c1"># ValueErrors</span>
    <span class="c1"># Check if df is empty</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;explore_num(): The input DataFrame is empty.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if list has any members</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">categorical_variables</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_cat(): The &#39;categorical_variables&#39; list must contain at least one column name.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if specified variables exist in the DataFrame</span>
    <span class="n">missing_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">categorical_variables</span> <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">missing_vars</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;transform_cat(): The following variables were not found in the DataFrame: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing_vars</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Check if variables are categorical</span>
    <span class="n">categorical_types</span> <span class="o">=</span> <span class="n">evaluate_dtype</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">categorical_variables</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;list_c&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">categorical_types</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_cat(): The &#39;categorical_variables&#39; list must contain only names of categorical variables.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if method is valid</span>
    <span class="n">valid_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;uniform_simple&#39;</span><span class="p">,</span> <span class="s1">&#39;uniform_smart&#39;</span><span class="p">,</span> <span class="s1">&#39;uniform_mapping&#39;</span><span class="p">,</span> <span class="s1">&#39;encode_onehot&#39;</span><span class="p">,</span> <span class="s1">&#39;encode_ordinal&#39;</span><span class="p">,</span> <span class="s1">&#39;encode_freq&#39;</span><span class="p">,</span> <span class="s1">&#39;encode_target&#39;</span><span class="p">,</span> <span class="s1">&#39;encode_binary&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_methods</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;transform_cat(): Invalid method &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39;. Valid options are: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">valid_methods</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Additional checks for method-specific parameters</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;encode_ordinal&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ordinal_map</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_cat(): The &#39;ordinal_map&#39; parameter must be provided when using the &#39;encode_ordinal&#39; method.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;encode_target&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">target_variable</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_cat(): The &#39;target_variable&#39; parameter must be provided when using the &#39;encode_target&#39; method.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;uniform_mapping&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">abbreviation_map</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform_cat(): The &#39;abbreviation_map&#39; parameter must be provided when using the &#39;uniform_mapping&#39; method.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if target_variable exists in the DataFrame for methods that require it</span>
    <span class="k">if</span> <span class="n">target_variable</span> <span class="ow">and</span> <span class="n">target_variable</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;transform_cat(): The target variable &#39;</span><span class="si">{</span><span class="n">target_variable</span><span class="si">}</span><span class="s2">&#39; was not found in the DataFrame.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if all keys in abbreviation_map are in the DataFrame columns</span>
    <span class="k">if</span> <span class="n">abbreviation_map</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">key</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">abbreviation_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">invalid_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">abbreviation_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;transform_cat(): The following keys in &#39;abbreviation_map&#39; were not found in the DataFrame columns: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invalid_keys</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Check if all keys in ordinal_map are in the DataFrame columns</span>
    <span class="k">if</span> <span class="n">ordinal_map</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">key</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ordinal_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">invalid_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ordinal_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;transform_cat(): The following keys in &#39;ordinal_map&#39; were not found in the DataFrame columns: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invalid_keys</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Main Function #</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;uniform_simple&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; UNIFORM SIMPLE TRANSFORMATION* &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method applies basic but effective transformations to make categorical data uniform:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Lowercases all text to fix capitalization inconsistencies.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Trims leading and trailing whitespaces for cleanliness.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Removes special characters to standardize text.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Fills missing values with a placeholder to maintain data integrity. (use na_placeholder = &#39;...&#39;, default &#39;Unknown&#39;)&quot;</span><span class="p">)</span>

        <span class="c1"># initialize dataframe to work with</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">uniform_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">categorical_variables</span><span class="p">:</span>
            <span class="c1"># Convert to handle missing values, lowercase, strip, and remove special characters</span>
            <span class="n">transformed_column</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
                <span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">na_placeholder</span><span class="p">)</span>  <span class="c1"># Customize this placeholder as needed</span>
                <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[^a-zA-Z0-9\s]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_column</span>
            <span class="n">uniform_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">uniform_columns</span><span class="p">,</span> <span class="n">transformed_column</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">[&#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39;] Category Transformation</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Categories BEFORE transformation (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Categories AFTER transformation (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only the uniform columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">uniform_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO: To catch the df&#39;s use - `transformed_df, uniform_columns = transform_cat(your_df, your_columns, method=&#39;uniform_simple&#39;)`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of original df: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of transformed df: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* For more advanced and nuanced data cleaning, consider using `uniform_smart`.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">uniform_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;uniform_smart&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; UNIFORM SMART TRANSFORMATION* &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method leverages advanced data cleaning techniques for categorical variables, enhancing uniformity across your dataset:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Utilizes the `uniform_simple` method for initial preprocessing steps.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Employs Levenshtein distance to evaluate textual similarity among categories.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Applies hierarchical clustering to group similar categories together.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Selects the most representative category within each cluster to ensure data consistency.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Fills missing values with a placeholder to maintain data integrity. (default &#39;Unknown&#39;, customize with na_placeholder = &#39;...&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize dataframe to work with</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">uniform_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">categorical_variables</span><span class="p">:</span>
            <span class="c1"># preprocess categories using uniform_simple method</span>
            <span class="n">categories</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
                <span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">na_placeholder</span><span class="p">)</span>  <span class="c1"># Customize this placeholder as needed</span>
                <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[^a-zA-Z0-9\s]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">unique_categories</span> <span class="o">=</span> <span class="n">categories</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

            <span class="c1"># calculate the similarity matrix using Levenshtein distance</span>
            <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">lev</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">)</span> <span class="k">for</span> <span class="n">w1</span> <span class="ow">in</span> <span class="n">unique_categories</span><span class="p">]</span> <span class="k">for</span> <span class="n">w2</span> <span class="ow">in</span> <span class="n">unique_categories</span><span class="p">])</span>
            <span class="n">max_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)</span>
            <span class="n">sim_matrix</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">dist_matrix</span> <span class="o">/</span> <span class="n">max_dist</span> <span class="k">if</span> <span class="n">max_dist</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)</span>

            <span class="c1"># perform hierarchical clustering on the similarity matrix</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">linkage</span><span class="p">(</span><span class="n">sim_matrix</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;complete&#39;</span><span class="p">)</span>
            <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">fcluster</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">)</span>

            <span class="c1"># assign each category to a cluster representative</span>
            <span class="n">representatives</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">cluster_categories</span> <span class="o">=</span> <span class="n">unique_categories</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="c1"># select the most frequent category within each cluster as the representative</span>
                <span class="n">representative</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cluster_categories</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">categories</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                <span class="n">representatives</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">representative</span>

            <span class="c1"># map each category in the original dataframe to its cluster representative</span>
            <span class="n">category_to_representative</span> <span class="o">=</span> <span class="p">{</span><span class="n">cat</span><span class="p">:</span> <span class="n">representatives</span><span class="p">[</span><span class="n">cluster_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_categories</span><span class="p">)}</span>
            <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">categories</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">category_to_representative</span><span class="p">)</span>

            <span class="c1"># add transformed column to uniform_columns DataFrame</span>
            <span class="n">uniform_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">uniform_columns</span><span class="p">,</span> <span class="n">transformed_df</span><span class="p">[[</span><span class="n">variable</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">[&#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39;] Category Transformation</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Categories BEFORE transformation (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Categories AFTER transformation (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only the uniform columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">uniform_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO: To catch the df&#39;s use - `transformed_df, uniform_columns = transform_cat(your_df, your_columns, method=&#39;uniform_smart&#39;)`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of original df: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Shape of transformed df: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Consider `uniform_simple` for basic data cleaning needs or when processing large datasets where computational efficiency is a concern.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">uniform_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;uniform_mapping&#39;</span> <span class="ow">and</span> <span class="n">abbreviation_map</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; MANUAL CATEGORY MAPPING &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method allows for manual mapping of categories to address specific cases:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Maps categories based on user-defined rules.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Useful for stubborn categories that automated methods can&#39;t uniformly transform.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✎ Note: Ensure your mapping dictionary is comprehensive for the best results.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize dataframe to work with</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">uniform_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">categorical_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">abbreviation_map</span><span class="p">:</span>
                <span class="c1"># apply mapping</span>
                <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">abbreviation_map</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                <span class="n">uniform_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">uniform_columns</span><span class="p">,</span> <span class="n">transformed_df</span><span class="p">[[</span><span class="n">variable</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">[&#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39;] Category Mapping</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Categories BEFORE mapping (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Categories AFTER mapping (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Original dataframe shape: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Transformed dataframe shape: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">uniform_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;encode_onehot&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; ONE-HOT ENCODING TRANSFORMATION &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method converts categorical variables into a form that could be provided to ML algorithms to do a better job in prediction:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Converts each category value into a new column and assigns a 1 or 0 (notation for true/false).&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Ensures the data is ready for machine learning models without assuming any ordinal relationship.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Helps to tackle the issue of &#39;curse of dimensionality&#39; in a controlled manner.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✎ Note: Before encoding, ensure data uniformity and cleanliness.</span><span class="se">\n</span><span class="s2">☻ Tip: Use `uniform_simple` or `uniform_smart` from `transform_cat()` for advanced categorical data cleaning.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize dataframe to work with</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># create an instance of one hot encoder</span>
        <span class="n">onehot_encoder</span> <span class="o">=</span> <span class="n">OneHotEncoder</span><span class="p">(</span><span class="n">sparse_output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># encode all variables at once for efficiency</span>
        <span class="n">encoded_data</span> <span class="o">=</span> <span class="n">onehot_encoder</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">categorical_variables</span><span class="p">])</span>

        <span class="c1"># convert the encoded data to a dataframe</span>
        <span class="n">encoded_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">encoded_data</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">onehot_encoder</span><span class="o">.</span><span class="n">get_feature_names_out</span><span class="p">(</span><span class="n">categorical_variables</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># reset indices of both dataframes to ensure they align when concatenating</span>
        <span class="n">transformed_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">encoded_columns</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># concatenate the original dataframe (minus the categorical columns) with the encoded columns</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">categorical_variables</span><span class="p">),</span> <span class="n">encoded_columns</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe with one-hot encoded variables:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Separate dataframe with only the one-hot encoded columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">encoded_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO: To catch the df&#39;s use - `transformed_df, encoded_columns = transform_cat(your_df, your_columns, method=&#39;encode_onehot&#39;)`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Original dataframe shape: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Transformed dataframe shape: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">encoded_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;encode_ordinal&#39;</span> <span class="ow">and</span> <span class="n">ordinal_map</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; ORDINAL ENCODING TRANSFORMATION &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method assigns an integer to each category value based on the provided ordinal order.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✎ Note: Ensure the provided ordinal map correctly reflects the desired order of categories for each variable.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ Tip: An ordinal map dictionary looks like this: {&#39;your_variable&#39;: [&#39;level1&#39;, &#39;level2&#39;, &#39;level3&#39;], ...}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize dataframe to work with</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">encoded_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># encode each variable according to the provided ordinal map</span>
        <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">ordinal_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">categorical_variables</span><span class="p">:</span>
                <span class="c1"># Prepare data for OrdinalEncoder</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">transformed_df</span><span class="p">[[</span><span class="n">variable</span><span class="p">]]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">categories</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span>

                <span class="c1"># Keep track of the newly encoded columns</span>
                <span class="n">encoded_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">encoded_columns</span><span class="p">,</span> <span class="n">transformed_df</span><span class="p">[[</span><span class="n">variable</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; encoded based on the specified order: </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;⚠️ &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; specified in `ordinal_map` was not found in `categorical_variables` and has been skipped.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only the ordinal encoded columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">encoded_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO - To catch the df&#39;s use: `transformed_df, encoded_columns = transform_cat(your_df, your_columns, method=&#39;encode_ordinal&#39;, ordinal_map=your_ordinal_map)`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Original dataframe shape: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Transformed dataframe shape: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">encoded_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;encode_freq&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; FREQUENCY ENCODING TRANSFORMATION &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method transforms categorical variables based on the frequency of each category.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✎ Note: Frequency encoding helps to retain the information about the category&#39;s prevalence.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ Tip: Useful for models where the frequency significance of categories impacts the prediction.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize dataframe to work with</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">encoded_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">categorical_variables</span><span class="p">:</span>
            <span class="c1"># calculate the frequency of each category</span>
            <span class="n">frequency_map</span> <span class="o">=</span> <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

            <span class="c1"># map the frequencies to the original dataframe</span>
            <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">frequency_map</span><span class="p">)</span>
            <span class="n">encoded_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">encoded_columns</span><span class="p">,</span> <span class="n">transformed_df</span><span class="p">[[</span><span class="n">variable</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; has been frequency encoded.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Dataframe with only frequency encoded columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">encoded_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO - to catch the df&#39;s: `transformed_df, encoded_columns = transform_cat(your_df, your_columns, method=&#39;encode_freq&#39;)`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Original dataframe shape: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Transformed dataframe shape: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">encoded_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;encode_target&#39;</span> <span class="ow">and</span> <span class="n">target_variable</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; TARGET ENCODING TRANSFORMATION* &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method encodes categorical variables based on the mean of the target variable for each category.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✎ Note: Target encoding captures the &#39;effect&#39; of each category on the target variable.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ Tip: To prevent data leakage and overfitting, apply target encoding within a cross-validation loop, ensuring it&#39;s computed separately for each fold.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize dataframe to work with</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">encoded_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">categorical_variables</span><span class="p">:</span>
            <span class="c1"># calculate the mean of the target variable for each category</span>
            <span class="n">target_means</span> <span class="o">=</span> <span class="n">transformed_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">variable</span><span class="p">)[</span><span class="n">target_variable</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

            <span class="c1"># map the computed means to the original categories</span>
            <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_df</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">target_means</span><span class="p">)</span>
            <span class="n">encoded_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">encoded_columns</span><span class="p">,</span> <span class="n">transformed_df</span><span class="p">[[</span><span class="n">variable</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39; has been target encoded with respect to &#39;</span><span class="si">{</span><span class="n">target_variable</span><span class="si">}</span><span class="s2">&#39;.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe with target encoded variables:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Separate dataframe with only the target encoded columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">encoded_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO - to catch the df&#39;s: `transformed_df, encoded_columns = transform_cat(your_df, your_columns, method=&#39;encode_target&#39;, target_variable=&#39;your_target_variable&#39;)`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Original dataframe shape: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Transformed dataframe shape: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">encoded_columns</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;encode_binary&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; BINARY ENCODING TRANSFORMATION &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; This method transforms categorical variables into binary columns, significantly reducing dimensionality for high cardinality features.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Efficiently handles categories by representing them with binary codes.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ✔ Reduces dataset size and model complexity compared to one-hot encoding.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✎ Note: Ideal for categorical variables with many unique categories.</span><span class="se">\n</span><span class="s2">☻ Tip: For categories with limited unique values, consider if binary encoding aligns with your data strategy.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># initialize dataframe to work with</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># create an instance of BinaryEncoder</span>
        <span class="n">binary_encoder</span> <span class="o">=</span> <span class="n">BinaryEncoder</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="n">categorical_variables</span><span class="p">)</span>

        <span class="c1"># keep a copy of the original columns, including the categorical ones that will be encoded</span>
        <span class="n">original_columns</span> <span class="o">=</span> <span class="n">transformed_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># fit and transform the data</span>
        <span class="n">transformed_df</span> <span class="o">=</span> <span class="n">binary_encoder</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">transformed_df</span><span class="p">)</span>

        <span class="c1"># determine the new columns by excluding the original columns</span>
        <span class="n">new_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">transformed_df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">original_columns</span><span class="p">]</span>
        <span class="c1"># note: this assumes the BinaryEncoder removes the original categorical columns</span>

        <span class="c1"># extract the newly created binary encoded columns for user reference</span>
        <span class="n">encoded_columns</span> <span class="o">=</span> <span class="n">transformed_df</span><span class="p">[</span><span class="n">new_columns</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ New transformed dataframe with binary encoded variables:</span><span class="se">\n</span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✔ Separate dataframe with only the binary encoded columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">encoded_columns</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;☻ HOW TO - to catch the new dfs: `transformed_df, encoded_columns = transform_cat(your_df, your_columns, method=&#39;encode_binary&#39;)`.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># sanity check</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt; SANITY CHECK &gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Original dataframe shape: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ➡ Transformed dataframe shape: </span><span class="si">{</span><span class="n">transformed_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_df</span><span class="p">,</span> <span class="n">encoded_columns</span></div>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, George Dreemer
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=8d563738"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=4e2eecee"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    </body>
</html>